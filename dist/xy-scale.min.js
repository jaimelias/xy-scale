var XY_Scale;(()=>{"use strict";var e={d:(r,t)=>{for(var n in t)e.o(t,n)&&!e.o(r,n)&&Object.defineProperty(r,n,{enumerable:!0,get:t[n]})},o:(e,r)=>Object.prototype.hasOwnProperty.call(e,r),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},r={};e.r(r),e.d(r,{arrayToTimesteps:()=>f,descaleArrayObj:()=>p,parseProductionX:()=>u,parseTrainingXY:()=>i});const t=({arrObj:e,repeat:r={},minmaxRange:t=[0,1],groups:i={},prevConfig:u=null})=>{const p=[...e],f=p.length,c=p[0];if(0===f)return{scaledOutput:[],scaledConfig:{}};let l={};const m=u&&o(u);if(m)s(u,{minmaxRange:t,repeat:r,groups:i,firstRow:c}),l={...u};else{const e=Object.keys(c),n=e.map((e=>r.hasOwnProperty(e)?Math.max(r[e],1):1)),a=n.reduce(((e,r)=>e+r),0);l={arrObjLen:f,rangeMin:t[0],rangeMax:t[1],inputTypes:{},min:{},max:{},uniqueStrIdx:{},groupMinMax:{},repeat:r,groups:i,inputKeyNames:e,outputKeyNames:new Array(a),repeatedKeyNames:n};let s=0;for(let e=0;e<l.inputKeyNames.length;e++)for(let r=0;r<l.repeatedKeyNames[e];r++)l.outputKeyNames[s++]=l.inputKeyNames[e];o(l)}n(l.groups);for(const e of l.inputKeyNames){const r=typeof c[e];if(m){if(!l.inputTypes.hasOwnProperty(e))throw new Error(`Error: A new unknown inputType property "${e}" found.`);if(l.inputTypes[e]!==r)throw new Error(`Error: Current inputType of property "${e}" is not the same as in the prevConfig inputType.`);continue}l.inputTypes[e]=r,"string"===r&&(l.uniqueStrIdx[e]={});const t=a(e,l.groups);t?l.groupMinMax[t]={min:1/0,max:-1/0}:(l.min[e]=1/0,l.max[e]=-1/0)}for(const e of p)for(const r of l.inputKeyNames){let t=e[r];if("string"===l.inputTypes[r]){const n=l.uniqueStrIdx[r];n.hasOwnProperty(t)||(n[t]=Object.keys(n).length),t=n[t],e[r]=t}else"boolean"===l.inputTypes[r]&&(e[r]=Number(t));const n=a(r,l.groups);n?(l.groupMinMax[n].min=Math.min(l.groupMinMax[n].min,t),l.groupMinMax[n].max=Math.max(l.groupMinMax[n].max,t)):(l.min[r]=Math.min(l.min[r],t),l.max[r]=Math.max(l.max[r],t))}const g=new Array(f);for(let e=0;e<f;e++){const r=p[e],t=new Array(l.outputKeyNames.length);let n=0;for(let e=0;e<l.inputKeyNames.length;e++){const o=l.inputKeyNames[e],s=r[o],i=a(o,l.groups);let u,p;i?(u=l.groupMinMax[i].min,p=l.groupMinMax[i].max):(u=l.min[o],p=l.max[o]);const f=p!==u?l.rangeMin+(s-u)/(p-u)*(l.rangeMax-l.rangeMin):l.rangeMin,c=l.repeatedKeyNames[e];for(let e=0;e<c;e++)t[n++]=f}g[e]=t}return{scaledOutput:g,scaledConfig:l}},n=e=>{const r=new Set,t=[];for(const[n,a]of Object.entries(e))r.add(n),t.push(n),a.forEach((e=>{r.add(e),t.push(e)}));if(r.size!==t.length)throw new Error("Duplicate value found between properties in validateUniqueProperties function.")},a=(e,r)=>{for(const[t,n]of Object.entries(r))if(n.includes(e))return t;return null},o=e=>{if(!e)return!1;const r=["rangeMin","rangeMax","inputTypes","min","max","uniqueStrIdx","groupMinMax","repeat","groups","inputKeyNames","outputKeyNames","repeatedKeyNames"];for(const t of r)if(!e.hasOwnProperty(t))throw new Error(`Missing key "${t}" in config.`);const{rangeMin:t,rangeMax:n,inputTypes:a,min:o,max:s,uniqueStrIdx:i,groupMinMax:u,repeat:p,groups:f,inputKeyNames:c,outputKeyNames:l,repeatedKeyNames:m}=e;if("number"!=typeof t||"number"!=typeof n)throw new Error("rangeMin and rangeMax must be numbers.");if(t>=n)throw new Error("rangeMin must be less than rangeMax.");const g=e=>"object"==typeof e&&null!==e&&!Array.isArray(e);if(!g(a))throw new Error("inputTypes must be an object.");if(!g(o))throw new Error("min must be an object.");if(!g(s))throw new Error("max must be an object.");if(!g(i))throw new Error("uniqueStrIdx must be an object.");if(!g(u))throw new Error("groupMinMax must be an object.");if(!g(p))throw new Error("repeat must be an object.");if(!g(f))throw new Error("groups must be an object.");if(!Array.isArray(c))throw new Error("inputKeyNames must be an array.");if(!Array.isArray(l))throw new Error("outputKeyNames must be an array.");if(!Array.isArray(m))throw new Error("repeatedKeyNames must be an array.");return!0},s=(e,{minmaxRange:r,repeat:t,groups:n,firstRow:a})=>{if(e.rangeMin!==r[0]||e.rangeMax!==r[1])throw new Error('"prevConfig.minmaxRange" is not equal "minmaxRange".');if(JSON.stringify(e.inputKeyNames)!==JSON.stringify(Object.keys(a)))throw new Error('"prevConfig.inputKeyNames" structure does not match "Object.keys(firstRow)" structure. The order of keys is important.');if(JSON.stringify(e.repeat)!==JSON.stringify(t))throw new Error('"prevConfig.repeat" structure does not match "repeat" structure. The order of keys is important.');if(JSON.stringify(e.groups)!==JSON.stringify(n))throw new Error('"prevConfig.groups" structure does not match "groups" structure. The order of keys is important.');return!0},i=({arrObj:e,trainingSplit:r=.8,repeat:n,yCallbackFunc:a,xCallbackFunc:o,validateRows:s=e=>e,groups:i,shuffle:u=!1,minmaxRange:p,balancing:f="",state:c={}})=>{let l=[],m=[];for(let r=0;r<e.length;r++){if(!s(e[r]))continue;const t=o({objRow:e,index:r,state:c}),n=a({objRow:e,index:r,state:c});null!=t&&null!=n&&(l.push(t),m.push(n))}if(u){const{shuffledX:e,shuffledY:r}=((e,r)=>{if(e.length!==r.length)throw new Error("X and Y arrays must have the same length");const t=Array.from({length:e.length},((e,r)=>r));for(let e=t.length-1;e>0;e--){const r=Math.floor(Math.random()*(e+1));[t[e],t[r]]=[t[r],t[e]]}return{shuffledX:t.map((r=>e[r])),shuffledY:t.map((e=>r[e]))}})(l,m);l=e,m=r}let{scaledOutput:g,scaledConfig:y}=t({arrObj:l,repeat:n,groups:i,minmaxRange:p}),{scaledOutput:h,scaledConfig:d}=t({arrObj:m,repeat:n,groups:i,minmaxRange:p});const w=Math.floor(g.length*r);let b=g.slice(0,w),x=h.slice(0,w),M=g.slice(w),O=h.slice(w);if(f){let e;if("oversample"===f)e=((e,r)=>{const t={},n={};r.forEach(((a,o)=>{t[a]||(t[a]=0,n[a]=[]),t[a]++,n[a].push([e[o],r[o]])}));const a=Math.max(...Object.values(t)),o=[],s=[];return Object.keys(n).forEach((e=>{const r=n[e],t=r.length;for(let e=0;e<a;e++){const n=r[e%t];o.push(n[0]),s.push(n[1])}})),{X:o,Y:s}})(b,x),b=e.X,x=e.Y;else{if("undersample"!==f)throw Error('balancing argument only accepts "false", "oversample" and "undersample". Defaults to "false".');e=((e,r)=>{const t={},n={};r.forEach(((a,o)=>{t[a]||(t[a]=0,n[a]=[]),t[a]++,n[a].push([e[o],r[o]])}));const a=Math.min(...Object.values(t)),o=[],s=[];return Object.keys(n).forEach((e=>{const r=n[e];for(let e=0;e<a;e++){const t=r[e];o.push(t[0]),s.push(t[1])}})),{X:o,Y:s}})(b,x),b=e.X,x=e.Y}}return{trainX:b,trainY:x,testX:M,testY:O,configX:y,configY:d}},u=({arrObj:e,repeat:r,xCallbackFunc:n,validateRows:a=e=>e,groups:o,shuffle:s=!1,minmaxRange:i,state:u={},prevConfig:p})=>{let f=[];for(let r=0;r<e.length;r++){if(!a(e[r]))continue;const t=n({objRow:e,index:r,state:u});t&&f.push(t)}s&&(f=(e=>{const r=[...e];for(let e=r.length-1;e>0;e--){const t=Math.floor(Math.random()*(e+1));[r[e],r[t]]=[r[t],r[e]]}return r})(f));const{scaledOutput:c,scaledConfig:l}=t({arrObj:f,repeat:r,groups:o,minmaxRange:i,prevConfig:p});return{X:c,configX:l,keyNamesX}},p=({scaled:e,config:r,keyNames:t})=>{const{min:n,max:a,std:o,mean:s,approach:i,inputTypes:u,uniqueStringIndexes:p}=r;return e.map((e=>{const r={};let f=0;for(const c of Object.keys(n)){const l=i[c],m=n[c],g=a[c],y=s[c],h=o[c],d=t.filter((e=>e===c)).length;let w=0;for(let r=0;r<d;r++)w+=e[f++];const b=w/d;let x;if("normalization"===l?x=b*(g-m)+m:"standardization"===l&&(x=b*h+y),"string"===u[c]){const e=Object.keys(p[c]).find((e=>p[c][e]===x));x=void 0!==e?e:x}r[c]=x}return r}))},f=(e,r)=>{if(0===r)return e;if(r<0)throw new Error("timeSteps must be greater than 0");const t=[];for(let n=0;n<=e.length-r;n++)t.push(e.slice(n,n+r));return t};XY_Scale=r})();