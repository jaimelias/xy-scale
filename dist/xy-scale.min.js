var XY_Scale;(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{arrayToTimesteps:()=>l,parseProductionX:()=>u,parseTrainingXY:()=>i});const n=({arrObj:e,repeat:t={},minmaxRange:n,groups:o={},customMinMaxRanges:s=null,excludes:i=new Set})=>{const u=[...e],l=u.length,c=u[0],p="object"==typeof s&&null!==s;if(0===l)return{scaledOutput:[],scaledConfig:{}};const m=Object.keys(c),f=m.map((e=>t.hasOwnProperty(e)?Math.max(t[e],1):1)),g=f.reduce(((e,t)=>e+t),0),d={arrObjLen:l,rangeMin:n[0],rangeMax:n[1],inputTypes:{},min:{},max:{},groupMinMax:{},repeat:t,groups:o,inputKeyNames:m,outputKeyNames:new Array(g),repeatedKeyNames:f};let h=0;for(let e=0;e<d.inputKeyNames.length;e++)for(let t=0;t<d.repeatedKeyNames[e];t++)d.outputKeyNames[h++]=d.inputKeyNames[e];r(d.groups);const x=["number","boolean"];for(const e of d.inputKeyNames){if(i.has(e)){d.inputTypes[e]="excluded";continue}const t=typeof c[e],n=a(e,d.groups);if(!x.includes(t))throw new Error(`Invalid input type "${t}" provided for key "${e}". Only accepting `);d.inputTypes[e]=t,p&&s.hasOwnProperty(e)?n?d.groupMinMax[n]=s[e]:(d.min[e]=s[e].min,d.max[e]=s[e].max):n?d.groupMinMax[n]={min:1/0,max:-1/0}:(d.min[e]=1/0,d.max[e]=-1/0)}for(const e of u)for(const t of d.inputKeyNames){if("excluded"===d.inputTypes[t])continue;let n=e[t];"boolean"===d.inputTypes[t]&&(e[t]=Number(n));const r=a(t,d.groups);(!1===p||p&&!s.hasOwnProperty(t))&&(r?(d.groupMinMax[r].min=Math.min(d.groupMinMax[r].min,n),d.groupMinMax[r].max=Math.max(d.groupMinMax[r].max,n)):(d.min[t]=Math.min(d.min[t],n),d.max[t]=Math.max(d.max[t],n)))}const y=new Array(l);for(let e=0;e<l;e++){const t=u[e],n=new Array(d.outputKeyNames.length);let r=0;for(let e=0;e<d.inputKeyNames.length;e++){const o=d.inputKeyNames[e],s=t[o];if("excluded"===d.inputTypes[o]){n[r++]=s;continue}const i=a(o,d.groups);let u,l;i?(u=d.groupMinMax[i].min,l=d.groupMinMax[i].max):(u=d.min[o],l=d.max[o]);const c=l!==u?d.rangeMin+(s-u)/(l-u)*(d.rangeMax-d.rangeMin):d.rangeMin,p=d.repeatedKeyNames[e];for(let e=0;e<p;e++)n[r++]=c}y[e]=n}return{scaledOutput:y,scaledConfig:d}},r=e=>{const t=new Set,n=[];for(const[r,a]of Object.entries(e))t.add(r),n.push(r),a.forEach((e=>{t.add(e),n.push(e)}));if(t.size!==n.length)throw new Error("Duplicate value found between properties in validateUniqueProperties function.")},a=(e,t)=>{for(const[n,r]of Object.entries(t))if(r.includes(e))return n;return null},o=(e,{min:t=-1/0,max:n=1/0},r)=>{if(!Array.isArray(e))throw new Error(`Invalid property. "${r}" expected an array.`);if(e.length<t)throw new Error(`Invalid property value. Array "${r}" expected at least ${n} items.`);if(e.length>n)throw new Error(`Invalid property value. Array "${r}" expected at max ${n} items.`);return!0},s=e=>(Object.entries(e).forEach(((e,t)=>{if(null==t||Number.isNaN(t))throw new Error(`Invalid value at index ${e}: value is ${t}. Expected a defined, non-null, numeric value.`)})),!0),i=({arrObj:e=[],trainingSplit:t=.8,repeat:r={},yCallbackFunc:a=e=>e,xCallbackFunc:i=e=>e,validateRows:u=()=>!0,groups:l={},shuffle:c=!1,minmaxRange:p=[0,1],balancing:m="",state:f={},customMinMaxRanges:g={},excludes:d=[]})=>{let h=[],x=[];o(e,{min:5},"parseTrainingXY"),s(e[0]);for(let t=0;t<e.length;t++){if(!u({objRow:e,index:t,state:f}))continue;const n=i({objRow:e,index:t,state:f}),r=a({objRow:e,index:t,state:f});null!=n&&null!=r&&(h.push(n),x.push(r))}if(c){const{shuffledX:e,shuffledY:t}=((e,t)=>{if(e.length!==t.length)throw new Error("X and Y arrays must have the same length");const n=Array.from({length:e.length},((e,t)=>t));for(let e=n.length-1;e>0;e--){const t=Math.floor(Math.random()*(e+1));[n[e],n[t]]=[n[t],n[e]]}return{shuffledX:n.map((t=>e[t])),shuffledY:n.map((e=>t[e]))}})(h,x);h=e,x=t}const y=new Set(d);let{scaledOutput:M,scaledConfig:b}=n({arrObj:h,repeat:r,groups:l,minmaxRange:p,customMinMaxRanges:g,excludes:y}),{scaledOutput:w,scaledConfig:O}=n({arrObj:x,repeat:r,groups:l,minmaxRange:p,customMinMaxRanges:g,excludes:y});const v=Math.floor(M.length*t);let j=M.slice(0,v),R=w.slice(0,v),X=M.slice(v),N=w.slice(v);if(m){let e;if("oversample"===m)e=((e,t)=>{const n={},r={};t.forEach(((a,o)=>{n[a]||(n[a]=0,r[a]=[]),n[a]++,r[a].push([e[o],t[o]])}));const a=Math.max(...Object.values(n)),o=[],s=[];return Object.keys(r).forEach((e=>{const t=r[e],n=t.length;for(let e=0;e<a;e++){const r=t[e%n];o.push(r[0]),s.push(r[1])}})),{X:o,Y:s}})(j,R),j=e.X,R=e.Y;else{if("undersample"!==m)throw Error('balancing argument only accepts "false", "oversample" and "undersample". Defaults to "false".');e=((e,t)=>{const n={},r={};t.forEach(((a,o)=>{n[a]||(n[a]=0,r[a]=[]),n[a]++,r[a].push([e[o],t[o]])}));const a=Math.min(...Object.values(n)),o=[],s=[];return Object.keys(r).forEach((e=>{const t=r[e];for(let e=0;e<a;e++){const n=t[e];o.push(n[0]),s.push(n[1])}})),{X:o,Y:s}})(j,R),j=e.X,R=e.Y}}return{trainX:j,trainY:R,testX:X,testY:N,configX:b,configY:O}},u=({arrObj:e=[],repeat:t={},xCallbackFunc:r=e=>e,validateRows:a=()=>!0,groups:i={},shuffle:u=!1,minmaxRange:l=[0,1],state:c={},customMinMaxRanges:p,excludes:m=[]})=>{let f=[];o(e,{min:5},"parseProductionX"),s(e[0]);for(let t=0;t<e.length;t++){if(!a(e[t]))continue;const n=r({objRow:e,index:t,state:c});null!=n&&!1!==n&&f.push(n)}u&&(f=(e=>{const t=[...e];for(let e=t.length-1;e>0;e--){const n=Math.floor(Math.random()*(e+1));[t[e],t[n]]=[t[n],t[e]]}return t})(f));const{scaledOutput:g,scaledConfig:d}=n({arrObj:f,repeat:t,groups:i,minmaxRange:l,customMinMaxRanges:p,excludes:new Set(m)});return{X:g,configX:d}},l=(e,t)=>{if(0===t)return e;if(t<0)throw new Error("timeSteps must be greater than 0");const n=[];for(let r=0;r<=e.length-t;r++)n.push(e.slice(r,r+t));return n};XY_Scale=t})();