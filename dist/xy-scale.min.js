var XY_Scale;(()=>{"use strict";var e={d:(t,n)=>{for(var o in n)e.o(n,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:n[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{arrayToTimesteps:()=>s,descaleArrayObj:()=>a,parseProductionX:()=>r,parseTrainingXY:()=>o});const n=({arrObj:e,weights:t={},forceScaling:n=null})=>{if(null!==n&&"normalization"!==n&&"standardization"!==n)throw Error('forceScaling should be null, "normalization" or "standardization"');const o=e.length;if(0===o)return{scaledOutput:[],scaledConfig:{},keyNames:[]};const r=Object.keys(e[0]),a=r.map((e=>t.hasOwnProperty(e)?Math.max(t[e],1):1)),s=a.reduce(((e,t)=>e+t),0),i=new Array(s);let l=0;for(let e=0;e<r.length;e++)for(let t=0;t<a[e];t++)i[l++]=r[e];const c={},f={},d={},u={},g={},p={},m={},h={};for(const t of r){const n=e[0][t];c[t]=typeof n,"string"===c[t]&&(m[t]={}),f[t]=1/0,d[t]=-1/0,u[t]=0,g[t]=0,h[t]=0}for(const t of e)for(const e of r){let n=t[e];if("string"===c[e]){const o=m[e];o.hasOwnProperty(n)||(o[n]=Object.keys(o).length),n=o[n],t[e]=n}f[e]=Math.min(f[e],n),d[e]=Math.max(d[e],n),h[e]++;const o=n-u[e];u[e]+=o/h[e],g[e]+=o*(n-u[e])}const y={};for(const e of r)y[e]=h[e]>1?Math.sqrt(g[e]/(h[e]-1)):0,"normalization"===n||"standardization"===n?p[e]=n:0===f[e]&&1===d[e]?p[e]="none":p[e]=y[e]<1?"normalization":"standardization";const b=new Array(o);for(let t=0;t<o;t++){const n=e[t],o=new Array(s);let i=0;for(let e=0;e<r.length;e++){const t=r[e],s=n[t],l=f[t],c=d[t],g=u[t],m=y[t];let h;h="none"===p[t]?s:"normalization"===p[t]?c!==l?(s-l)/(c-l):0:0!==m?(s-g)/m:0;const b=a[e];for(let e=0;e<b;e++)o[i++]=h}b[t]=o}return{scaledOutput:b,scaledConfig:{min:f,max:d,std:y,mean:u,approach:p,inputTypes:c,uniqueStringIndexes:m},scaledKeyNames:i}},o=({arrObj:e,trainingSplit:t=.8,weights:o={},yCallbackFunc:r,xCallbackFunc:a,forceScaling:s,timeSteps:i=0})=>{const l=[],c=[];for(let t=0;t<e.length;t++){const n=a({objRow:e,index:t}),o=r({objRow:e,index:t});null!=n&&null!=o&&(l.push(n),c.push(o))}const{scaledOutput:f,scaledConfig:d,scaledKeyNames:u}=n({arrObj:l,weights:o,forceScaling:s}),{scaledOutput:g,scaledConfig:p,scaledKeyNames:m}=n({arrObj:c,weights:o,forceScaling:s}),h=Math.floor(f.length*t);return{trainX:f.slice(0,h),trainY:g.slice(0,h),testX:f.slice(h),testY:g.slice(h),configX:d,keyNamesX:u,configY:p,keyNamesY:m}},r=({arrObj:e,weights:t={},xCallbackFunc:o,forceScaling:r,timeSteps:a=0})=>{const s=[];for(let t=0;t<e.length;t++){const n=o({objRow:e,index:t});n&&s.push(n)}const{scaledOutput:i,scaledConfig:l,scaledKeyNames:c}=n({arrObj:s,weights:t,forceScaling:r});return{X:i,configX:l,keyNamesX:c}},a=({scaled:e,config:t,keyNames:n})=>{const{min:o,max:r,std:a,mean:s,approach:i,inputTypes:l,uniqueStringIndexes:c}=t;return e.map((e=>{const t={};let f=0;for(const d of Object.keys(o)){const u=i[d],g=o[d],p=r[d],m=s[d],h=a[d],y=n.filter((e=>e===d)).length;let b=0;for(let t=0;t<y;t++)b+=e[f++];const O=b/y;let S;if("normalization"===u?S=O*(p-g)+g:"standardization"===u&&(S=O*h+m),"string"===l[d]){const e=Object.keys(c[d]).find((e=>c[d][e]===S));S=void 0!==e?e:S}t[d]=S}return t}))},s=(e,t)=>{if(0===t)return e;if(t<0)throw new Error("timeSteps must be greater than 0");const n=[];for(let o=0;o<=e.length-t;o++)n.push(e.slice(o,o+t));return n};XY_Scale=t})();