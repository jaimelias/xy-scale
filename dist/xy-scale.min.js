var XY_Scale;(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{arrayToTimesteps:()=>c,descaleArrayObj:()=>l,parseProductionX:()=>s,parseTrainingXY:()=>o});const n=({arrObj:e,repeat:t={},minmaxRange:n=[0,1],groups:o={}})=>{const s=e.length;if(r(o),0===s)return{scaledOutput:[],scaledConfig:{},keyNames:[]};const[l,c]=n;if(l>=c)throw new Error("Invalid minmaxRange: rangeMin must be less than rangeMax");const i=Object.keys(e[0]),u=i.map((e=>t.hasOwnProperty(e)?Math.max(t[e],1):1)),f=u.reduce(((e,t)=>e+t),0),m=new Array(f);let h=0;for(let e=0;e<i.length;e++)for(let t=0;t<u[e];t++)m[h++]=i[e];const p={},g={},d={},b={},y={};for(const t of i){const n=e[0][t];p[t]=typeof n,"string"===p[t]&&(b[t]={});const r=a(t,o);r?y[r]||(y[r]={min:1/0,max:-1/0}):(g[t]=1/0,d[t]=-1/0)}for(const t of e)for(const e of i){let n=t[e];if("string"===p[e]){const r=b[e];r.hasOwnProperty(n)||(r[n]=Object.keys(r).length),n=r[n],t[e]=n}else"boolean"===p[e]&&(t[e]=Number(n));const r=a(e,o);r?(y[r].min=Math.min(y[r].min,n),y[r].max=Math.max(y[r].max,n)):(g[e]=Math.min(g[e],n),d[e]=Math.max(d[e],n))}const O=new Array(s);for(let t=0;t<s;t++){const n=e[t],r=new Array(f);let s=0;for(let e=0;e<i.length;e++){const t=i[e],f=n[t],m=a(t,o);let h,p;m?(h=y[m].min,p=y[m].max):(h=g[t],p=d[t]);const b=p!==h?l+(f-h)/(p-h)*(c-l):l,O=u[e];for(let e=0;e<O;e++)r[s++]=b}O[t]=r}return{scaledOutput:O,scaledConfig:{min:g,max:d,inputTypes:p,uniqueStringIndexes:b,rangeMin:l,rangeMax:c,groupMinMax:y},scaledKeyNames:m}},r=e=>{const t=new Set,n=[];for(const[r,a]of Object.entries(e))t.add(r),n.push(r),a.forEach((e=>{t.add(e),n.push(e)}));if(t.size!==n.length)throw new Error("Duplicate value found between properties in validateUniqueProperties function.")},a=(e,t)=>{for(const[n,r]of Object.entries(t))if(r.includes(e))return n;return null},o=({arrObj:e,trainingSplit:t=.8,repeat:r={},yCallbackFunc:a,xCallbackFunc:o,groups:s,shuffle:l=!1,minmaxRange:c,balancing:i=""})=>{let u=[],f=[];for(let t=0;t<e.length;t++){const n=o({objRow:e,index:t}),r=a({objRow:e,index:t});null!=n&&null!=r&&(u.push(n),f.push(r))}if(l){const{shuffledX:e,shuffledY:t}=((e,t)=>{if(e.length!==t.length)throw new Error("X and Y arrays must have the same length");const n=Array.from({length:e.length},((e,t)=>t));for(let e=n.length-1;e>0;e--){const t=Math.floor(Math.random()*(e+1));[n[e],n[t]]=[n[t],n[e]]}return{shuffledX:n.map((t=>e[t])),shuffledY:n.map((e=>t[e]))}})(u,f);u=e,f=t}let{scaledOutput:m,scaledConfig:h,scaledKeyNames:p}=n({arrObj:u,repeat:r,groups:s,minmaxRange:c}),{scaledOutput:g,scaledConfig:d,scaledKeyNames:b}=n({arrObj:f,repeat:r,groups:s,minmaxRange:c});if(i){let e;if("oversample"===i)e=((e,t)=>{const n={},r={};t.forEach(((a,o)=>{n[a]||(n[a]=0,r[a]=[]),n[a]++,r[a].push([e[o],t[o]])}));const a=Math.max(...Object.values(n)),o=[],s=[];return Object.keys(r).forEach((e=>{const t=r[e],n=t.length;for(let e=0;e<a;e++){const r=t[e%n];o.push(r[0]),s.push(r[1])}})),{X:o,Y:s}})(m,g),m=e.X,g=e.Y;else{if("undersample"!==i)throw Error('balancing argument only accepts "false", "oversample" and "undersample". Defaults to "false".');e=((e,t)=>{const n={},r={};t.forEach(((a,o)=>{n[a]||(n[a]=0,r[a]=[]),n[a]++,r[a].push([e[o],t[o]])}));const a=Math.min(...Object.values(n)),o=[],s=[];return Object.keys(r).forEach((e=>{const t=r[e];for(let e=0;e<a;e++){const n=t[e];o.push(n[0]),s.push(n[1])}})),{X:o,Y:s}})(m,g),m=e.X,g=e.Y}}const y=Math.floor(m.length*t);return{trainX:m.slice(0,y),trainY:g.slice(0,y),testX:m.slice(y),testY:g.slice(y),configX:h,keyNamesX:p,configY:d,keyNamesY:b}},s=({arrObj:e,repeat:t={},xCallbackFunc:r,groups:a,shuffle:o=!1,minmaxRange:s})=>{let l=[];for(let t=0;t<e.length;t++){const n=r({objRow:e,index:t});n&&l.push(n)}o&&(l=(e=>{const t=[...e];for(let e=t.length-1;e>0;e--){const n=Math.floor(Math.random()*(e+1));[t[e],t[n]]=[t[n],t[e]]}return t})(l));const{scaledOutput:c,scaledConfig:i,scaledKeyNames:u}=n({arrObj:l,repeat:t,groups:a,minmaxRange:s});return{X:c,configX:i,keyNamesX:u}},l=({scaled:e,config:t,keyNames:n})=>{const{min:r,max:a,std:o,mean:s,approach:l,inputTypes:c,uniqueStringIndexes:i}=t;return e.map((e=>{const t={};let u=0;for(const f of Object.keys(r)){const m=l[f],h=r[f],p=a[f],g=s[f],d=o[f],b=n.filter((e=>e===f)).length;let y=0;for(let t=0;t<b;t++)y+=e[u++];const O=y/b;let x;if("normalization"===m?x=O*(p-h)+h:"standardization"===m&&(x=O*d+g),"string"===c[f]){const e=Object.keys(i[f]).find((e=>i[f][e]===x));x=void 0!==e?e:x}t[f]=x}return t}))},c=(e,t)=>{if(0===t)return e;if(t<0)throw new Error("timeSteps must be greater than 0");const n=[];for(let r=0;r<=e.length-t;r++)n.push(e.slice(r,r+t));return n};XY_Scale=t})();