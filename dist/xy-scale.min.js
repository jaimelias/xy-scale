var XY_Scale;(()=>{"use strict";var e={d:(r,t)=>{for(var n in t)e.o(t,n)&&!e.o(r,n)&&Object.defineProperty(r,n,{enumerable:!0,get:t[n]})},o:(e,r)=>Object.prototype.hasOwnProperty.call(e,r),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},r={};e.r(r),e.d(r,{arrayToTimesteps:()=>p,parseProductionX:()=>u,parseTrainingXY:()=>i});const t=({arrObj:e,repeat:r={},minmaxRange:t=[0,1],groups:i={},prevConfig:u=null,customMinMaxRanges:p=null})=>{const m=[...e],f=m.length,l=m[0],c="object"==typeof p&&null!==p;if(0===f)return{scaledOutput:[],scaledConfig:{}};let g={};const h=u&&o(u);if(h)s(u,{minmaxRange:t,repeat:r,groups:i,firstRow:l}),g={...u};else{const e=Object.keys(l),n=e.map((e=>r.hasOwnProperty(e)?Math.max(r[e],1):1)),a=n.reduce(((e,r)=>e+r),0);g={arrObjLen:f,rangeMin:t[0],rangeMax:t[1],inputTypes:{},min:{},max:{},uniqueStrIdx:{},groupMinMax:{},repeat:r,groups:i,inputKeyNames:e,outputKeyNames:new Array(a),repeatedKeyNames:n};let s=0;for(let e=0;e<g.inputKeyNames.length;e++)for(let r=0;r<g.repeatedKeyNames[e];r++)g.outputKeyNames[s++]=g.inputKeyNames[e];o(g)}n(g.groups);for(const e of g.inputKeyNames){const r=typeof l[e],t=a(e,g.groups);if(h){if(!g.inputTypes.hasOwnProperty(e))throw new Error(`Error: A new unknown inputType property "${e}" found.`);if(g.inputTypes[e]!==r)throw new Error(`Error: Current inputType of property "${e}" is not the same as in the prevConfig inputType.`)}else g.inputTypes[e]=r,"string"===r&&(g.uniqueStrIdx[e]={}),c&&p.hasOwnProperty(e)?t?g.groupMinMax[t]=p[e]:(g.min[e]=p[e].min,g.max[e]=p[e].max):t?g.groupMinMax[t]={min:1/0,max:-1/0}:(g.min[e]=1/0,g.max[e]=-1/0)}for(const e of m)for(const r of g.inputKeyNames){let t=e[r];if("string"===g.inputTypes[r]){const n=g.uniqueStrIdx[r];n.hasOwnProperty(t)||(n[t]=Object.keys(n).length),t=n[t],e[r]=t}else"boolean"===g.inputTypes[r]&&(e[r]=Number(t));const n=a(r,g.groups);(!1===c||c&&!p.hasOwnProperty(r))&&(n?(g.groupMinMax[n].min=Math.min(g.groupMinMax[n].min,t),g.groupMinMax[n].max=Math.max(g.groupMinMax[n].max,t)):(g.min[r]=Math.min(g.min[r],t),g.max[r]=Math.max(g.max[r],t)))}const y=new Array(f);for(let e=0;e<f;e++){const r=m[e],t=new Array(g.outputKeyNames.length);let n=0;for(let e=0;e<g.inputKeyNames.length;e++){const o=g.inputKeyNames[e],s=r[o],i=a(o,g.groups);let u,p;i?(u=g.groupMinMax[i].min,p=g.groupMinMax[i].max):(u=g.min[o],p=g.max[o]);const m=p!==u?g.rangeMin+(s-u)/(p-u)*(g.rangeMax-g.rangeMin):g.rangeMin,f=g.repeatedKeyNames[e];for(let e=0;e<f;e++)t[n++]=m}y[e]=t}return{scaledOutput:y,scaledConfig:g}},n=e=>{const r=new Set,t=[];for(const[n,a]of Object.entries(e))r.add(n),t.push(n),a.forEach((e=>{r.add(e),t.push(e)}));if(r.size!==t.length)throw new Error("Duplicate value found between properties in validateUniqueProperties function.")},a=(e,r)=>{for(const[t,n]of Object.entries(r))if(n.includes(e))return t;return null},o=e=>{if(!e)return!1;const r=["rangeMin","rangeMax","inputTypes","min","max","uniqueStrIdx","groupMinMax","repeat","groups","inputKeyNames","outputKeyNames","repeatedKeyNames"];for(const t of r)if(!e.hasOwnProperty(t))throw new Error(`Missing key "${t}" in config.`);const{rangeMin:t,rangeMax:n,inputTypes:a,min:o,max:s,uniqueStrIdx:i,groupMinMax:u,repeat:p,groups:m,inputKeyNames:f,outputKeyNames:l,repeatedKeyNames:c}=e;if("number"!=typeof t||"number"!=typeof n)throw new Error("rangeMin and rangeMax must be numbers.");if(t>=n)throw new Error("rangeMin must be less than rangeMax.");const g=e=>"object"==typeof e&&null!==e&&!Array.isArray(e);if(!g(a))throw new Error("inputTypes must be an object.");if(!g(o))throw new Error("min must be an object.");if(!g(s))throw new Error("max must be an object.");if(!g(i))throw new Error("uniqueStrIdx must be an object.");if(!g(u))throw new Error("groupMinMax must be an object.");if(!g(p))throw new Error("repeat must be an object.");if(!g(m))throw new Error("groups must be an object.");if(!Array.isArray(f))throw new Error("inputKeyNames must be an array.");if(!Array.isArray(l))throw new Error("outputKeyNames must be an array.");if(!Array.isArray(c))throw new Error("repeatedKeyNames must be an array.");return!0},s=(e,{minmaxRange:r,repeat:t,groups:n,firstRow:a})=>{if(e.rangeMin!==r[0]||e.rangeMax!==r[1])throw new Error('"prevConfig.minmaxRange" is not equal "minmaxRange".');if(JSON.stringify(e.inputKeyNames)!==JSON.stringify(Object.keys(a)))throw new Error('"prevConfig.inputKeyNames" structure does not match "Object.keys(firstRow)" structure. The order of keys is important.');if(JSON.stringify(e.repeat)!==JSON.stringify(t))throw new Error('"prevConfig.repeat" structure does not match "repeat" structure. The order of keys is important.');if(JSON.stringify(e.groups)!==JSON.stringify(n))throw new Error('"prevConfig.groups" structure does not match "groups" structure. The order of keys is important.');return!0},i=({arrObj:e,trainingSplit:r=.8,repeat:n,yCallbackFunc:a=e=>e,xCallbackFunc:o=e=>e,validateRows:s=()=>!0,groups:i,shuffle:u=!1,minmaxRange:p,balancing:m="",state:f={},customMinMaxRanges:l})=>{let c=[],g=[];for(let r=0;r<e.length;r++){if(!s(e[r]))continue;const t=o({objRow:e,index:r,state:f}),n=a({objRow:e,index:r,state:f});null!=t&&null!=n&&(c.push(t),g.push(n))}if(u){const{shuffledX:e,shuffledY:r}=((e,r)=>{if(e.length!==r.length)throw new Error("X and Y arrays must have the same length");const t=Array.from({length:e.length},((e,r)=>r));for(let e=t.length-1;e>0;e--){const r=Math.floor(Math.random()*(e+1));[t[e],t[r]]=[t[r],t[e]]}return{shuffledX:t.map((r=>e[r])),shuffledY:t.map((e=>r[e]))}})(c,g);c=e,g=r}let{scaledOutput:h,scaledConfig:y}=t({arrObj:c,repeat:n,groups:i,minmaxRange:p,customMinMaxRanges:l}),{scaledOutput:w,scaledConfig:M}=t({arrObj:g,repeat:n,groups:i,minmaxRange:p,customMinMaxRanges:l});const x=Math.floor(h.length*r);let d=h.slice(0,x),b=w.slice(0,x),O=h.slice(x),j=w.slice(x);if(m){let e;if("oversample"===m)e=((e,r)=>{const t={},n={};r.forEach(((a,o)=>{t[a]||(t[a]=0,n[a]=[]),t[a]++,n[a].push([e[o],r[o]])}));const a=Math.max(...Object.values(t)),o=[],s=[];return Object.keys(n).forEach((e=>{const r=n[e],t=r.length;for(let e=0;e<a;e++){const n=r[e%t];o.push(n[0]),s.push(n[1])}})),{X:o,Y:s}})(d,b),d=e.X,b=e.Y;else{if("undersample"!==m)throw Error('balancing argument only accepts "false", "oversample" and "undersample". Defaults to "false".');e=((e,r)=>{const t={},n={};r.forEach(((a,o)=>{t[a]||(t[a]=0,n[a]=[]),t[a]++,n[a].push([e[o],r[o]])}));const a=Math.min(...Object.values(t)),o=[],s=[];return Object.keys(n).forEach((e=>{const r=n[e];for(let e=0;e<a;e++){const t=r[e];o.push(t[0]),s.push(t[1])}})),{X:o,Y:s}})(d,b),d=e.X,b=e.Y}}return{trainX:d,trainY:b,testX:O,testY:j,configX:y,configY:M}},u=({arrObj:e,repeat:r,xCallbackFunc:n=e=>e,validateRows:a=()=>!0,groups:o,shuffle:s=!1,minmaxRange:i,state:u={},prevConfig:p,customMinMaxRanges:m})=>{let f=[];for(let r=0;r<e.length;r++){if(!a(e[r]))continue;const t=n({objRow:e,index:r,state:u});null!=t&&!1!==t&&f.push(t)}s&&(f=(e=>{const r=[...e];for(let e=r.length-1;e>0;e--){const t=Math.floor(Math.random()*(e+1));[r[e],r[t]]=[r[t],r[e]]}return r})(f));const{scaledOutput:l,scaledConfig:c}=t({arrObj:f,repeat:r,groups:o,minmaxRange:i,prevConfig:p,customMinMaxRanges:m});return{X:l,configX:c}},p=(e,r)=>{if(0===r)return e;if(r<0)throw new Error("timeSteps must be greater than 0");const t=[];for(let n=0;n<=e.length-r;n++)t.push(e.slice(n,n+r));return t};XY_Scale=r})();