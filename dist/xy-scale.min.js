var XY_Scale;(()=>{"use strict";var e={d:(t,n)=>{for(var a in n)e.o(n,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:n[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{arrayToTimesteps:()=>i,parseProductionX:()=>s,parseTrainingXY:()=>o});const n=({arrObj:e,repeat:t={},minmaxRange:n=[0,1],groups:o={},customMinMaxRanges:s=null})=>{const i=[...e],u=i.length,l=i[0],c="object"==typeof s&&null!==s;if(0===u)return{scaledOutput:[],scaledConfig:{}};const p=Object.keys(l),m=p.map((e=>t.hasOwnProperty(e)?Math.max(t[e],1):1)),f=m.reduce(((e,t)=>e+t),0),g={arrObjLen:u,rangeMin:n[0],rangeMax:n[1],inputTypes:{},min:{},max:{},groupMinMax:{},repeat:t,groups:o,inputKeyNames:p,outputKeyNames:new Array(f),repeatedKeyNames:m};let h=0;for(let e=0;e<g.inputKeyNames.length;e++)for(let t=0;t<g.repeatedKeyNames[e];t++)g.outputKeyNames[h++]=g.inputKeyNames[e];a(g.groups);const d=["number","boolean"];for(const e of g.inputKeyNames){const t=typeof l[e],n=r(e,g.groups);if(!d.includes(t))throw new Error(`Invalid input type "${t}" provided for key "${e}". Only accepting `);g.inputTypes[e]=t,c&&s.hasOwnProperty(e)?n?g.groupMinMax[n]=s[e]:(g.min[e]=s[e].min,g.max[e]=s[e].max):n?g.groupMinMax[n]={min:1/0,max:-1/0}:(g.min[e]=1/0,g.max[e]=-1/0)}for(const e of i)for(const t of g.inputKeyNames){let n=e[t];"boolean"===g.inputTypes[t]&&(e[t]=Number(n));const a=r(t,g.groups);(!1===c||c&&!s.hasOwnProperty(t))&&(a?(g.groupMinMax[a].min=Math.min(g.groupMinMax[a].min,n),g.groupMinMax[a].max=Math.max(g.groupMinMax[a].max,n)):(g.min[t]=Math.min(g.min[t],n),g.max[t]=Math.max(g.max[t],n)))}const M=new Array(u);for(let e=0;e<u;e++){const t=i[e],n=new Array(g.outputKeyNames.length);let a=0;for(let e=0;e<g.inputKeyNames.length;e++){const o=g.inputKeyNames[e],s=t[o],i=r(o,g.groups);let u,l;i?(u=g.groupMinMax[i].min,l=g.groupMinMax[i].max):(u=g.min[o],l=g.max[o]);const c=l!==u?g.rangeMin+(s-u)/(l-u)*(g.rangeMax-g.rangeMin):g.rangeMin,p=g.repeatedKeyNames[e];for(let e=0;e<p;e++)n[a++]=c}M[e]=n}return{scaledOutput:M,scaledConfig:g}},a=e=>{const t=new Set,n=[];for(const[a,r]of Object.entries(e))t.add(a),n.push(a),r.forEach((e=>{t.add(e),n.push(e)}));if(t.size!==n.length)throw new Error("Duplicate value found between properties in validateUniqueProperties function.")},r=(e,t)=>{for(const[n,a]of Object.entries(t))if(a.includes(e))return n;return null},o=({arrObj:e,trainingSplit:t=.8,repeat:a,yCallbackFunc:r=e=>e,xCallbackFunc:o=e=>e,validateRows:s=()=>!0,groups:i,shuffle:u=!1,minmaxRange:l,balancing:c="",state:p={},customMinMaxRanges:m})=>{let f=[],g=[];for(let t=0;t<e.length;t++){if(!s({objRow:e,index:t,state:p}))continue;const n=o({objRow:e,index:t,state:p}),a=r({objRow:e,index:t,state:p});null!=n&&null!=a&&(f.push(n),g.push(a))}if(u){const{shuffledX:e,shuffledY:t}=((e,t)=>{if(e.length!==t.length)throw new Error("X and Y arrays must have the same length");const n=Array.from({length:e.length},((e,t)=>t));for(let e=n.length-1;e>0;e--){const t=Math.floor(Math.random()*(e+1));[n[e],n[t]]=[n[t],n[e]]}return{shuffledX:n.map((t=>e[t])),shuffledY:n.map((e=>t[e]))}})(f,g);f=e,g=t}let{scaledOutput:h,scaledConfig:d}=n({arrObj:f,repeat:a,groups:i,minmaxRange:l,customMinMaxRanges:m}),{scaledOutput:M,scaledConfig:x}=n({arrObj:g,repeat:a,groups:i,minmaxRange:l,customMinMaxRanges:m});const y=Math.floor(h.length*t);let b=h.slice(0,y),O=M.slice(0,y),w=h.slice(y),j=M.slice(y);if(c){let e;if("oversample"===c)e=((e,t)=>{const n={},a={};t.forEach(((r,o)=>{n[r]||(n[r]=0,a[r]=[]),n[r]++,a[r].push([e[o],t[o]])}));const r=Math.max(...Object.values(n)),o=[],s=[];return Object.keys(a).forEach((e=>{const t=a[e],n=t.length;for(let e=0;e<r;e++){const a=t[e%n];o.push(a[0]),s.push(a[1])}})),{X:o,Y:s}})(b,O),b=e.X,O=e.Y;else{if("undersample"!==c)throw Error('balancing argument only accepts "false", "oversample" and "undersample". Defaults to "false".');e=((e,t)=>{const n={},a={};t.forEach(((r,o)=>{n[r]||(n[r]=0,a[r]=[]),n[r]++,a[r].push([e[o],t[o]])}));const r=Math.min(...Object.values(n)),o=[],s=[];return Object.keys(a).forEach((e=>{const t=a[e];for(let e=0;e<r;e++){const n=t[e];o.push(n[0]),s.push(n[1])}})),{X:o,Y:s}})(b,O),b=e.X,O=e.Y}}return{trainX:b,trainY:O,testX:w,testY:j,configX:d,configY:x}},s=({arrObj:e,repeat:t,xCallbackFunc:a=e=>e,validateRows:r=()=>!0,groups:o,shuffle:s=!1,minmaxRange:i,state:u={},prevConfig:l,customMinMaxRanges:c})=>{let p=[];for(let t=0;t<e.length;t++){if(!r(e[t]))continue;const n=a({objRow:e,index:t,state:u});null!=n&&!1!==n&&p.push(n)}s&&(p=(e=>{const t=[...e];for(let e=t.length-1;e>0;e--){const n=Math.floor(Math.random()*(e+1));[t[e],t[n]]=[t[n],t[e]]}return t})(p));const{scaledOutput:m,scaledConfig:f}=n({arrObj:p,repeat:t,groups:o,minmaxRange:i,prevConfig:l,customMinMaxRanges:c});return{X:m,configX:f}},i=(e,t)=>{if(0===t)return e;if(t<0)throw new Error("timeSteps must be greater than 0");const n=[];for(let a=0;a<=e.length-t;a++)n.push(e.slice(a,a+t));return n};XY_Scale=t})();