var XY_Scale;(()=>{"use strict";var e={d:(r,t)=>{for(var n in t)e.o(t,n)&&!e.o(r,n)&&Object.defineProperty(r,n,{enumerable:!0,get:t[n]})},o:(e,r)=>Object.prototype.hasOwnProperty.call(e,r),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},r={};e.r(r),e.d(r,{arrayToTimesteps:()=>m,descaleArrayObj:()=>p,parseProductionX:()=>u,parseTrainingXY:()=>i});const t=({arrObj:e,repeat:r={},minmaxRange:t=[0,1],groups:i={},prevConfig:u=null,customMinMaxRanges:p=null})=>{const m=[...e],c=m.length,f=m[0],l="object"==typeof p&&null!==p;if(0===c)return{scaledOutput:[],scaledConfig:{}};let g={};const y=u&&o(u);if(y)s(u,{minmaxRange:t,repeat:r,groups:i,firstRow:f}),g={...u};else{const e=Object.keys(f),n=e.map((e=>r.hasOwnProperty(e)?Math.max(r[e],1):1)),a=n.reduce(((e,r)=>e+r),0);g={arrObjLen:c,rangeMin:t[0],rangeMax:t[1],inputTypes:{},min:{},max:{},uniqueStrIdx:{},groupMinMax:{},repeat:r,groups:i,inputKeyNames:e,outputKeyNames:new Array(a),repeatedKeyNames:n};let s=0;for(let e=0;e<g.inputKeyNames.length;e++)for(let r=0;r<g.repeatedKeyNames[e];r++)g.outputKeyNames[s++]=g.inputKeyNames[e];o(g)}n(g.groups);for(const e of g.inputKeyNames){const r=typeof f[e],t=a(e,g.groups);if(y){if(!g.inputTypes.hasOwnProperty(e))throw new Error(`Error: A new unknown inputType property "${e}" found.`);if(g.inputTypes[e]!==r)throw new Error(`Error: Current inputType of property "${e}" is not the same as in the prevConfig inputType.`)}else g.inputTypes[e]=r,"string"===r&&(g.uniqueStrIdx[e]={}),l&&p.hasOwnProperty(e)?t?g.groupMinMax[t]=p[e]:(g.min[e]=p[e].min,g.max[e]=-p[e].max):t?g.groupMinMax[t]={min:1/0,max:-1/0}:(g.min[e]=1/0,g.max[e]=-1/0)}for(const e of m)for(const r of g.inputKeyNames){let t=e[r];if("string"===g.inputTypes[r]){const n=g.uniqueStrIdx[r];n.hasOwnProperty(t)||(n[t]=Object.keys(n).length),t=n[t],e[r]=t}else"boolean"===g.inputTypes[r]&&(e[r]=Number(t));const n=a(r,g.groups);(!1===l||l&&!p.hasOwnProperty(r))&&(n?(g.groupMinMax[n].min=Math.min(g.groupMinMax[n].min,t),g.groupMinMax[n].max=Math.max(g.groupMinMax[n].max,t)):(g.min[r]=Math.min(g.min[r],t),g.max[r]=Math.max(g.max[r],t)))}const h=new Array(c);for(let e=0;e<c;e++){const r=m[e],t=new Array(g.outputKeyNames.length);let n=0;for(let e=0;e<g.inputKeyNames.length;e++){const o=g.inputKeyNames[e],s=r[o],i=a(o,g.groups);let u,p;i?(u=g.groupMinMax[i].min,p=g.groupMinMax[i].max):(u=g.min[o],p=g.max[o]);const m=p!==u?g.rangeMin+(s-u)/(p-u)*(g.rangeMax-g.rangeMin):g.rangeMin,c=g.repeatedKeyNames[e];for(let e=0;e<c;e++)t[n++]=m}h[e]=t}return{scaledOutput:h,scaledConfig:g}},n=e=>{const r=new Set,t=[];for(const[n,a]of Object.entries(e))r.add(n),t.push(n),a.forEach((e=>{r.add(e),t.push(e)}));if(r.size!==t.length)throw new Error("Duplicate value found between properties in validateUniqueProperties function.")},a=(e,r)=>{for(const[t,n]of Object.entries(r))if(n.includes(e))return t;return null},o=e=>{if(!e)return!1;const r=["rangeMin","rangeMax","inputTypes","min","max","uniqueStrIdx","groupMinMax","repeat","groups","inputKeyNames","outputKeyNames","repeatedKeyNames"];for(const t of r)if(!e.hasOwnProperty(t))throw new Error(`Missing key "${t}" in config.`);const{rangeMin:t,rangeMax:n,inputTypes:a,min:o,max:s,uniqueStrIdx:i,groupMinMax:u,repeat:p,groups:m,inputKeyNames:c,outputKeyNames:f,repeatedKeyNames:l}=e;if("number"!=typeof t||"number"!=typeof n)throw new Error("rangeMin and rangeMax must be numbers.");if(t>=n)throw new Error("rangeMin must be less than rangeMax.");const g=e=>"object"==typeof e&&null!==e&&!Array.isArray(e);if(!g(a))throw new Error("inputTypes must be an object.");if(!g(o))throw new Error("min must be an object.");if(!g(s))throw new Error("max must be an object.");if(!g(i))throw new Error("uniqueStrIdx must be an object.");if(!g(u))throw new Error("groupMinMax must be an object.");if(!g(p))throw new Error("repeat must be an object.");if(!g(m))throw new Error("groups must be an object.");if(!Array.isArray(c))throw new Error("inputKeyNames must be an array.");if(!Array.isArray(f))throw new Error("outputKeyNames must be an array.");if(!Array.isArray(l))throw new Error("repeatedKeyNames must be an array.");return!0},s=(e,{minmaxRange:r,repeat:t,groups:n,firstRow:a})=>{if(e.rangeMin!==r[0]||e.rangeMax!==r[1])throw new Error('"prevConfig.minmaxRange" is not equal "minmaxRange".');if(JSON.stringify(e.inputKeyNames)!==JSON.stringify(Object.keys(a)))throw new Error('"prevConfig.inputKeyNames" structure does not match "Object.keys(firstRow)" structure. The order of keys is important.');if(JSON.stringify(e.repeat)!==JSON.stringify(t))throw new Error('"prevConfig.repeat" structure does not match "repeat" structure. The order of keys is important.');if(JSON.stringify(e.groups)!==JSON.stringify(n))throw new Error('"prevConfig.groups" structure does not match "groups" structure. The order of keys is important.');return!0},i=({arrObj:e,trainingSplit:r=.8,repeat:n,yCallbackFunc:a,xCallbackFunc:o,validateRows:s=e=>e,groups:i,shuffle:u=!1,minmaxRange:p,balancing:m="",state:c={},customMinMaxRanges:f})=>{let l=[],g=[];for(let r=0;r<e.length;r++){if(!s(e[r]))continue;const t=o({objRow:e,index:r,state:c}),n=a({objRow:e,index:r,state:c});null!=t&&null!=n&&(l.push(t),g.push(n))}if(u){const{shuffledX:e,shuffledY:r}=((e,r)=>{if(e.length!==r.length)throw new Error("X and Y arrays must have the same length");const t=Array.from({length:e.length},((e,r)=>r));for(let e=t.length-1;e>0;e--){const r=Math.floor(Math.random()*(e+1));[t[e],t[r]]=[t[r],t[e]]}return{shuffledX:t.map((r=>e[r])),shuffledY:t.map((e=>r[e]))}})(l,g);l=e,g=r}let{scaledOutput:y,scaledConfig:h}=t({arrObj:l,repeat:n,groups:i,minmaxRange:p,customMinMaxRanges:f}),{scaledOutput:d,scaledConfig:w}=t({arrObj:g,repeat:n,groups:i,minmaxRange:p,customMinMaxRanges:f});const M=Math.floor(y.length*r);let x=y.slice(0,M),b=d.slice(0,M),O=y.slice(M),j=d.slice(M);if(m){let e;if("oversample"===m)e=((e,r)=>{const t={},n={};r.forEach(((a,o)=>{t[a]||(t[a]=0,n[a]=[]),t[a]++,n[a].push([e[o],r[o]])}));const a=Math.max(...Object.values(t)),o=[],s=[];return Object.keys(n).forEach((e=>{const r=n[e],t=r.length;for(let e=0;e<a;e++){const n=r[e%t];o.push(n[0]),s.push(n[1])}})),{X:o,Y:s}})(x,b),x=e.X,b=e.Y;else{if("undersample"!==m)throw Error('balancing argument only accepts "false", "oversample" and "undersample". Defaults to "false".');e=((e,r)=>{const t={},n={};r.forEach(((a,o)=>{t[a]||(t[a]=0,n[a]=[]),t[a]++,n[a].push([e[o],r[o]])}));const a=Math.min(...Object.values(t)),o=[],s=[];return Object.keys(n).forEach((e=>{const r=n[e];for(let e=0;e<a;e++){const t=r[e];o.push(t[0]),s.push(t[1])}})),{X:o,Y:s}})(x,b),x=e.X,b=e.Y}}return{trainX:x,trainY:b,testX:O,testY:j,configX:h,configY:w}},u=({arrObj:e,repeat:r,xCallbackFunc:n,validateRows:a=e=>e,groups:o,shuffle:s=!1,minmaxRange:i,state:u={},prevConfig:p,customMinMaxRanges:m})=>{let c=[];for(let r=0;r<e.length;r++){if(!a(e[r]))continue;const t=n({objRow:e,index:r,state:u});t&&c.push(t)}s&&(c=(e=>{const r=[...e];for(let e=r.length-1;e>0;e--){const t=Math.floor(Math.random()*(e+1));[r[e],r[t]]=[r[t],r[e]]}return r})(c));const{scaledOutput:f,scaledConfig:l}=t({arrObj:c,repeat:r,groups:o,minmaxRange:i,prevConfig:p,customMinMaxRanges:m});return{X:f,configX:l,keyNamesX}},p=({scaled:e,config:r,keyNames:t})=>{const{min:n,max:a,std:o,mean:s,approach:i,inputTypes:u,uniqueStringIndexes:p}=r;return e.map((e=>{const r={};let m=0;for(const c of Object.keys(n)){const f=i[c],l=n[c],g=a[c],y=s[c],h=o[c],d=t.filter((e=>e===c)).length;let w=0;for(let r=0;r<d;r++)w+=e[m++];const M=w/d;let x;if("normalization"===f?x=M*(g-l)+l:"standardization"===f&&(x=M*h+y),"string"===u[c]){const e=Object.keys(p[c]).find((e=>p[c][e]===x));x=void 0!==e?e:x}r[c]=x}return r}))},m=(e,r)=>{if(0===r)return e;if(r<0)throw new Error("timeSteps must be greater than 0");const t=[];for(let n=0;n<=e.length-r;n++)t.push(e.slice(n,n+r));return t};XY_Scale=r})();