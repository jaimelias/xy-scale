var XY_Scale;(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{arrayToTimesteps:()=>i,descaleArrayObj:()=>l,parseProductionX:()=>a,parseTrainingXY:()=>s});const n=({arrObj:e,weights:t={},minmaxRange:n=[0,1],groups:s={}})=>{const a=e.length;if(r(s),0===a)return{scaledOutput:[],scaledConfig:{},keyNames:[]};const[l,i]=n;if(l>=i)throw new Error("Invalid minmaxRange: rangeMin must be less than rangeMax");const c=Object.keys(e[0]),u=c.map((e=>t.hasOwnProperty(e)?Math.max(t[e],1):1)),f=u.reduce(((e,t)=>e+t),0),g=new Array(f);let h=0;for(let e=0;e<c.length;e++)for(let t=0;t<u[e];t++)g[h++]=c[e];const d={},m={},p={},y={},b={};for(const t of c){const n=e[0][t];d[t]=typeof n,"string"===d[t]&&(y[t]={});const r=o(t,s);r?b[r]||(b[r]={min:1/0,max:-1/0}):(m[t]=1/0,p[t]=-1/0)}for(const t of e)for(const e of c){let n=t[e];if("string"===d[e]){const r=y[e];r.hasOwnProperty(n)||(r[n]=Object.keys(r).length),n=r[n],t[e]=n}else"boolean"===d[e]&&(t[e]=Number(n));const r=o(e,s);r?(b[r].min=Math.min(b[r].min,n),b[r].max=Math.max(b[r].max,n)):(m[e]=Math.min(m[e],n),p[e]=Math.max(p[e],n))}const w=new Array(a);for(let t=0;t<a;t++){const n=e[t],r=new Array(f);let a=0;for(let e=0;e<c.length;e++){const t=c[e],f=n[t],g=o(t,s);let h,d;g?(h=b[g].min,d=b[g].max):(h=m[t],d=p[t]);const y=d!==h?l+(f-h)/(d-h)*(i-l):l,w=u[e];for(let e=0;e<w;e++)r[a++]=y}w[t]=r}return{scaledOutput:w,scaledConfig:{min:m,max:p,inputTypes:d,uniqueStringIndexes:y,rangeMin:l,rangeMax:i,groupMinMax:b},scaledKeyNames:g}},r=e=>{const t=new Set,n=[];for(const[r,o]of Object.entries(e))t.add(r),n.push(r),o.forEach((e=>{t.add(e),n.push(e)}));if(t.size!==n.length)throw new Error("Duplicate value found between properties in validateUniqueProperties function.")},o=(e,t)=>{for(const[n,r]of Object.entries(t))if(r.includes(e))return n;return null},s=({arrObj:e,trainingSplit:t=.8,weights:r={},yCallbackFunc:o,xCallbackFunc:s,groups:a,shuffle:l=!1})=>{let i=[],c=[];for(let t=0;t<e.length;t++){const n=s({objRow:e,index:t}),r=o({objRow:e,index:t});null!=n&&null!=r&&(i.push(n),c.push(r))}if(l){const{shuffledX:e,shuffledY:t}=((e,t)=>{if(e.length!==t.length)throw new Error("X and Y arrays must have the same length");const n=Array.from({length:e.length},((e,t)=>t));for(let e=n.length-1;e>0;e--){const t=Math.floor(Math.random()*(e+1));[n[e],n[t]]=[n[t],n[e]]}return{shuffledX:n.map((t=>e[t])),shuffledY:n.map((e=>t[e]))}})(i,c);i=e,c=t}const{scaledOutput:u,scaledConfig:f,scaledKeyNames:g}=n({arrObj:i,weights:r,groups:a}),{scaledOutput:h,scaledConfig:d,scaledKeyNames:m}=n({arrObj:c,weights:r,groups:a}),p=Math.floor(u.length*t);return{trainX:u.slice(0,p),trainY:h.slice(0,p),testX:u.slice(p),testY:h.slice(p),configX:f,keyNamesX:g,configY:d,keyNamesY:m}},a=({arrObj:e,weights:t={},xCallbackFunc:r,groups:o,shuffle:s=!1})=>{let a=[];for(let t=0;t<e.length;t++){const n=r({objRow:e,index:t});n&&a.push(n)}s&&(a=(e=>{const t=[...e];for(let e=t.length-1;e>0;e--){const n=Math.floor(Math.random()*(e+1));[t[e],t[n]]=[t[n],t[e]]}return t})(a));const{scaledOutput:l,scaledConfig:i,scaledKeyNames:c}=n({arrObj:a,weights:t,groups:o});return{X:l,configX:i,keyNamesX:c}},l=({scaled:e,config:t,keyNames:n})=>{const{min:r,max:o,std:s,mean:a,approach:l,inputTypes:i,uniqueStringIndexes:c}=t;return e.map((e=>{const t={};let u=0;for(const f of Object.keys(r)){const g=l[f],h=r[f],d=o[f],m=a[f],p=s[f],y=n.filter((e=>e===f)).length;let b=0;for(let t=0;t<y;t++)b+=e[u++];const w=b/y;let O;if("normalization"===g?O=w*(d-h)+h:"standardization"===g&&(O=w*p+m),"string"===i[f]){const e=Object.keys(c[f]).find((e=>c[f][e]===O));O=void 0!==e?e:O}t[f]=O}return t}))},i=(e,t)=>{if(0===t)return e;if(t<0)throw new Error("timeSteps must be greater than 0");const n=[];for(let r=0;r<=e.length-t;r++)n.push(e.slice(r,r+t));return n};XY_Scale=t})();