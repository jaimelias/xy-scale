var XY_Scale;(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{arrayToTimesteps:()=>c,parseProductionX:()=>l,parseTrainingXY:()=>u});const n=({arrObj:e,repeat:t={},minmaxRange:n,groups:o={},customMinMaxRanges:s=null,excludes:i=new Set})=>{const u=[...e],l=u.length,c=u[0],p="object"==typeof s&&null!==s;if(0===l)return{scaledOutput:[],scaledConfig:{}};const f=Object.keys(c),m=f.map((e=>t.hasOwnProperty(e)?Math.max(t[e],1):1)),d=m.reduce(((e,t)=>e+t),0),g={arrObjLen:l,rangeMin:n[0],rangeMax:n[1],inputTypes:{},min:{},max:{},groupMinMax:{},repeat:t,groups:o,inputKeyNames:f,outputKeyNames:new Array(d),repeatedKeyNames:m};let h=0;for(let e=0;e<g.inputKeyNames.length;e++)for(let t=0;t<g.repeatedKeyNames[e];t++)g.outputKeyNames[h++]=g.inputKeyNames[e];r(g.groups);const y=["number","boolean"];for(const e of g.inputKeyNames){if(i.has(e)){g.inputTypes[e]="excluded";continue}const t=typeof c[e],n=a(e,g.groups);if(!y.includes(t))throw new Error(`Invalid input type "${t}" provided for key "${e}". Only accepting `);g.inputTypes[e]=t,p&&s.hasOwnProperty(e)?n?g.groupMinMax[n]=s[e]:(g.min[e]=s[e].min,g.max[e]=s[e].max):n?g.groupMinMax[n]={min:1/0,max:-1/0}:(g.min[e]=1/0,g.max[e]=-1/0)}for(const e of u)for(const t of g.inputKeyNames){if("excluded"===g.inputTypes[t])continue;let n=e[t];"boolean"===g.inputTypes[t]&&(e[t]=Number(n));const r=a(t,g.groups);(!1===p||p&&!s.hasOwnProperty(t))&&(r?(g.groupMinMax[r].min=Math.min(g.groupMinMax[r].min,n),g.groupMinMax[r].max=Math.max(g.groupMinMax[r].max,n)):(g.min[t]=Math.min(g.min[t],n),g.max[t]=Math.max(g.max[t],n)))}const x=new Array(l);for(let e=0;e<l;e++){const t=u[e],n=new Array(g.outputKeyNames.length);let r=0;for(let e=0;e<g.inputKeyNames.length;e++){const o=g.inputKeyNames[e],s=t[o];if("excluded"===g.inputTypes[o]){n[r++]=s;continue}const i=a(o,g.groups);let u,l;i?(u=g.groupMinMax[i].min,l=g.groupMinMax[i].max):(u=g.min[o],l=g.max[o]);const c=l!==u?g.rangeMin+(s-u)/(l-u)*(g.rangeMax-g.rangeMin):g.rangeMin,p=g.repeatedKeyNames[e];for(let e=0;e<p;e++)n[r++]=c}x[e]=n}return{scaledOutput:x,scaledConfig:g}},r=e=>{const t=new Set,n=[];for(const[r,a]of Object.entries(e))t.add(r),n.push(r),a.forEach((e=>{t.add(e),n.push(e)}));if(t.size!==n.length)throw new Error("Duplicate value found between properties in validateUniqueProperties function.")},a=(e,t)=>{for(const[n,r]of Object.entries(t))if(r.includes(e))return n;return null},o=(e,t)=>{const n=Object.keys(e);if(!Array.isArray(t))throw new Error('Property "excludes" must be an array.');for(const e of t)if(!n.includes(e))throw new Error(`An item in "excludes" property was not found in "arrObj".\n\nexcludes: ${JSON.stringify(t)}\n\narrObj: ${JSON.stringify(n)}`)},s=(e,{min:t=-1/0,max:n=1/0},r)=>{if(!Array.isArray(e))throw new Error(`Invalid property. "${r}" expected an array.`);if(e.length<t)throw new Error(`Invalid property value. Array "${r}" expected at least ${n} items.`);if(e.length>n)throw new Error(`Invalid property value. Array "${r}" expected at max ${n} items.`);return!0},i=e=>{for(const[t,n]of Object.entries(e)){if("number"==typeof n&&Number.isNaN(n))throw new Error(`Invalid value at index 0 property "${t}": value is "${n}". Expected a numeric value.`);if(null===n)throw new Error(`Invalid value at index 0 property "${t}": value is "${n}".`)}return!0},u=({arrObj:e=[],trainingSplit:t=.8,repeat:r={},yCallbackFunc:a=e=>e,xCallbackFunc:u=e=>e,validateRows:l=()=>!0,groups:c={},shuffle:p=!1,minmaxRange:f=[0,1],balancing:m="",state:d={},customMinMaxRanges:g={},excludes:h=[]})=>{let y=[],x=[];s(e,{min:5},"parseTrainingXY"),i(e[0]),o(e[0],h);for(let t=0;t<e.length;t++){if(!l({objRow:e,index:t,state:d}))continue;const n=u({objRow:e,index:t,state:d}),r=a({objRow:e,index:t,state:d});null!=n&&null!=r&&(y.push(n),x.push(r))}if(p){const{shuffledX:e,shuffledY:t}=((e,t)=>{if(e.length!==t.length)throw new Error("X and Y arrays must have the same length");const n=Array.from({length:e.length},((e,t)=>t));for(let e=n.length-1;e>0;e--){const t=Math.floor(Math.random()*(e+1));[n[e],n[t]]=[n[t],n[e]]}return{shuffledX:n.map((t=>e[t])),shuffledY:n.map((e=>t[e]))}})(y,x);y=e,x=t}const M=new Set(h);let{scaledOutput:b,scaledConfig:w}=n({arrObj:y,repeat:r,groups:c,minmaxRange:f,customMinMaxRanges:g,excludes:M});const O=x.length,v=new Array(O),j={keyNames:Object.keys(x[0])};for(let e=0;e<O;e++)v[e]=Object.values(x[e]);const N=Math.floor(b.length*t);let E=b.slice(0,N),X=v.slice(0,N),R=b.slice(N),S=v.slice(N);if(m){let e;if("oversample"===m)e=((e,t)=>{const n={},r={};t.forEach(((a,o)=>{n[a]||(n[a]=0,r[a]=[]),n[a]++,r[a].push([e[o],t[o]])}));const a=Math.max(...Object.values(n)),o=[],s=[];return Object.keys(r).forEach((e=>{const t=r[e],n=t.length;for(let e=0;e<a;e++){const r=t[e%n];o.push(r[0]),s.push(r[1])}})),{X:o,Y:s}})(E,X),E=e.X,X=e.Y;else{if("undersample"!==m)throw Error('balancing argument only accepts "false", "oversample" and "undersample". Defaults to "false".');e=((e,t)=>{const n={},r={};t.forEach(((a,o)=>{n[a]||(n[a]=0,r[a]=[]),n[a]++,r[a].push([e[o],t[o]])}));const a=Math.min(...Object.values(n)),o=[],s=[];return Object.keys(r).forEach((e=>{const t=r[e];for(let e=0;e<a;e++){const n=t[e];o.push(n[0]),s.push(n[1])}})),{X:o,Y:s}})(E,X),E=e.X,X=e.Y}}return{trainX:E,trainY:X,testX:R,testY:S,configX:w,configY:j}},l=({arrObj:e=[],repeat:t={},xCallbackFunc:r=e=>e,validateRows:a=()=>!0,groups:u={},shuffle:l=!1,minmaxRange:c=[0,1],state:p={},customMinMaxRanges:f,excludes:m=[]})=>{let d=[];s(e,{min:5},"parseProductionX"),i(e[0]),o(e[0],m);for(let t=0;t<e.length;t++){if(!a(e[t]))continue;const n=r({objRow:e,index:t,state:p});null!=n&&!1!==n&&d.push(n)}l&&(d=(e=>{const t=[...e];for(let e=t.length-1;e>0;e--){const n=Math.floor(Math.random()*(e+1));[t[e],t[n]]=[t[n],t[e]]}return t})(d));const{scaledOutput:g,scaledConfig:h}=n({arrObj:d,repeat:t,groups:u,minmaxRange:c,customMinMaxRanges:f,excludes:new Set(m)});return{X:g,configX:h}},c=(e,t)=>{if(0===t)return e;if(t<0)throw new Error("timeSteps must be greater than 0");const n=[];for(let r=0;r<=e.length-t;r++)n.push(e.slice(r,r+t));return n};XY_Scale=t})();