var XY_Scale;(()=>{"use strict";var e={d:(t,n)=>{for(var a in n)e.o(n,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:n[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{arrayToTimesteps:()=>u,parseProductionX:()=>s,parseTrainingXY:()=>o});const n=({arrObj:e,repeat:t={},minmaxRange:n=[0,1],groups:o={},customMinMaxRanges:s=null,excludes:u=new Set})=>{const i=[...e],l=i.length,c=i[0],p="object"==typeof s&&null!==s;if(0===l)return{scaledOutput:[],scaledConfig:{}};const m=Object.keys(c),f=m.map((e=>t.hasOwnProperty(e)?Math.max(t[e],1):1)),g=f.reduce(((e,t)=>e+t),0),h={arrObjLen:l,rangeMin:n[0],rangeMax:n[1],inputTypes:{},min:{},max:{},groupMinMax:{},repeat:t,groups:o,inputKeyNames:m,outputKeyNames:new Array(g),repeatedKeyNames:f};let d=0;for(let e=0;e<h.inputKeyNames.length;e++)for(let t=0;t<h.repeatedKeyNames[e];t++)h.outputKeyNames[d++]=h.inputKeyNames[e];a(h.groups);const x=["number","boolean"];for(const e of h.inputKeyNames){if(u.has(e)){h.inputTypes[e]="excluded";continue}const t=typeof c[e],n=r(e,h.groups);if(!x.includes(t))throw new Error(`Invalid input type "${t}" provided for key "${e}". Only accepting `);h.inputTypes[e]=t,p&&s.hasOwnProperty(e)?n?h.groupMinMax[n]=s[e]:(h.min[e]=s[e].min,h.max[e]=s[e].max):n?h.groupMinMax[n]={min:1/0,max:-1/0}:(h.min[e]=1/0,h.max[e]=-1/0)}for(const e of i)for(const t of h.inputKeyNames){if("excluded"===h.inputTypes[t])continue;let n=e[t];"boolean"===h.inputTypes[t]&&(e[t]=Number(n));const a=r(t,h.groups);(!1===p||p&&!s.hasOwnProperty(t))&&(a?(h.groupMinMax[a].min=Math.min(h.groupMinMax[a].min,n),h.groupMinMax[a].max=Math.max(h.groupMinMax[a].max,n)):(h.min[t]=Math.min(h.min[t],n),h.max[t]=Math.max(h.max[t],n)))}const M=new Array(l);for(let e=0;e<l;e++){const t=i[e],n=new Array(h.outputKeyNames.length);let a=0;for(let e=0;e<h.inputKeyNames.length;e++){const o=h.inputKeyNames[e],s=t[o];if("excluded"===h.inputTypes[o]){n[a++]=s;continue}const u=r(o,h.groups);let i,l;u?(i=h.groupMinMax[u].min,l=h.groupMinMax[u].max):(i=h.min[o],l=h.max[o]);const c=l!==i?h.rangeMin+(s-i)/(l-i)*(h.rangeMax-h.rangeMin):h.rangeMin,p=h.repeatedKeyNames[e];for(let e=0;e<p;e++)n[a++]=c}M[e]=n}return{scaledOutput:M,scaledConfig:h}},a=e=>{const t=new Set,n=[];for(const[a,r]of Object.entries(e))t.add(a),n.push(a),r.forEach((e=>{t.add(e),n.push(e)}));if(t.size!==n.length)throw new Error("Duplicate value found between properties in validateUniqueProperties function.")},r=(e,t)=>{for(const[n,a]of Object.entries(t))if(a.includes(e))return n;return null},o=({arrObj:e=[],trainingSplit:t=.8,repeat:a={},yCallbackFunc:r=e=>e,xCallbackFunc:o=e=>e,validateRows:s=()=>!0,groups:u={},shuffle:i=!1,minmaxRange:l=[],balancing:c="",state:p={},customMinMaxRanges:m={},excludes:f=[]})=>{let g=[],h=[];for(let t=0;t<e.length;t++){if(!s({objRow:e,index:t,state:p}))continue;const n=o({objRow:e,index:t,state:p}),a=r({objRow:e,index:t,state:p});null!=n&&null!=a&&(g.push(n),h.push(a))}if(i){const{shuffledX:e,shuffledY:t}=((e,t)=>{if(e.length!==t.length)throw new Error("X and Y arrays must have the same length");const n=Array.from({length:e.length},((e,t)=>t));for(let e=n.length-1;e>0;e--){const t=Math.floor(Math.random()*(e+1));[n[e],n[t]]=[n[t],n[e]]}return{shuffledX:n.map((t=>e[t])),shuffledY:n.map((e=>t[e]))}})(g,h);g=e,h=t}const d=new Set(f);let{scaledOutput:x,scaledConfig:M}=n({arrObj:g,repeat:a,groups:u,minmaxRange:l,customMinMaxRanges:m,excludes:d}),{scaledOutput:y,scaledConfig:b}=n({arrObj:h,repeat:a,groups:u,minmaxRange:l,customMinMaxRanges:m,excludes:d});const O=Math.floor(x.length*t);let w=x.slice(0,O),j=y.slice(0,O),R=x.slice(O),v=y.slice(O);if(c){let e;if("oversample"===c)e=((e,t)=>{const n={},a={};t.forEach(((r,o)=>{n[r]||(n[r]=0,a[r]=[]),n[r]++,a[r].push([e[o],t[o]])}));const r=Math.max(...Object.values(n)),o=[],s=[];return Object.keys(a).forEach((e=>{const t=a[e],n=t.length;for(let e=0;e<r;e++){const a=t[e%n];o.push(a[0]),s.push(a[1])}})),{X:o,Y:s}})(w,j),w=e.X,j=e.Y;else{if("undersample"!==c)throw Error('balancing argument only accepts "false", "oversample" and "undersample". Defaults to "false".');e=((e,t)=>{const n={},a={};t.forEach(((r,o)=>{n[r]||(n[r]=0,a[r]=[]),n[r]++,a[r].push([e[o],t[o]])}));const r=Math.min(...Object.values(n)),o=[],s=[];return Object.keys(a).forEach((e=>{const t=a[e];for(let e=0;e<r;e++){const n=t[e];o.push(n[0]),s.push(n[1])}})),{X:o,Y:s}})(w,j),w=e.X,j=e.Y}}return{trainX:w,trainY:j,testX:R,testY:v,configX:M,configY:b}},s=({arrObj:e=[],repeat:t={},xCallbackFunc:a=e=>e,validateRows:r=()=>!0,groups:o={},shuffle:s=!1,minmaxRange:u=[],state:i={},customMinMaxRanges:l,excludes:c=[]})=>{let p=[];for(let t=0;t<e.length;t++){if(!r(e[t]))continue;const n=a({objRow:e,index:t,state:i});null!=n&&!1!==n&&p.push(n)}s&&(p=(e=>{const t=[...e];for(let e=t.length-1;e>0;e--){const n=Math.floor(Math.random()*(e+1));[t[e],t[n]]=[t[n],t[e]]}return t})(p));const{scaledOutput:m,scaledConfig:f}=n({arrObj:p,repeat:t,groups:o,minmaxRange:u,customMinMaxRanges:l,excludes:new Set(c)});return{X:m,configX:f}},u=(e,t)=>{if(0===t)return e;if(t<0)throw new Error("timeSteps must be greater than 0");const n=[];for(let a=0;a<=e.length-t;a++)n.push(e.slice(a,a+t));return n};XY_Scale=t})();