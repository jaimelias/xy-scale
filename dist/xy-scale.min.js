var XY_Scale;(()=>{"use strict";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{parseProductionX:()=>a,parseTrainingXY:()=>o});const n=({arrObj:e,weights:t={},forceScaling:n=null})=>{if(null!==n&&"normalization"!==n&&"standardization"!==n)throw Error('forceScalling should be null, "normalization" or "standardization"');const r=e.length;if(0===r)return{scaledOutput:[],scaledConfig:{},keyNames:[]};const o=Object.keys(e[0]),a=o.map((e=>{if(t.hasOwnProperty(e)){const n=t[e];if(n<=0)throw new Error(`Weight for key "${e}" must be positive.`);return n}return 1})),s=a.reduce(((e,t)=>e+t),0),i=new Array(s);let c=0;for(let e=0;e<o.length;e++){const t=o[e],n=a[e];for(let e=0;e<n;e++)i[c++]=t}const l={},f={},u={},g={},d={},p={},h={},y={};for(const t of o){const n=e[0][t];l[t]=typeof n,"string"===l[t]&&(h[t]={}),f[t]=1/0,u[t]=-1/0,g[t]=0,d[t]=0,y[t]=0}for(const t of e)for(const e of o){let n=t[e];if("string"===l[e]){const r=h[e];r.hasOwnProperty(n)||(r[n]=Object.keys(r).length),n=r[n],t[e]=n}n<f[e]&&(f[e]=n),n>u[e]&&(u[e]=n),y[e]++;const r=n-g[e];g[e]+=r/y[e],d[e]+=r*(n-g[e])}const m={};for(const e of o)m[e]=y[e]>1?Math.sqrt(d[e]/(y[e]-1)):0,p[e]="normalization"===n||"standardization"===n?n:m[e]<1?"normalization":"standardization";const b=new Array(r);for(let t=0;t<r;t++){const n=e[t],r=new Array(s);let i=0;for(let e=0;e<o.length;e++){const t=o[e],s=n[t],c=f[t],l=u[t],d=g[t],h=m[t];let y;y="normalization"===p[t]?l!==c?(s-c)/(l-c):0:0!==h?(s-d)/h:0;const b=a[e];for(let e=0;e<b;e++)r[i++]=y}b[t]=r}return{scaledOutput:b,scaledConfig:{min:f,max:u,std:m,mean:g,approach:p,inputTypes:l,uniqueStringIndexes:h},scaledKeyNames:i}},r=(e,t)=>{if(0===t)return e;if(t<0)throw new Error("timeSteps must be greater than 0");const n=[];for(let r=0;r<=e.length-t;r++)n.push(e.slice(r,r+t));return n},o=({arrObj:e,trainingSplit:t=.8,weights:o={},yCallbackFunc:a,xCallbackFunc:s,forceScaling:i,timeSteps:c=0})=>{const l=[],f=[];for(let t=0;t<e.length;t++){const n=s({objRow:e,index:t}),r=a({objRow:e,index:t});n&&r&&(l.push(n),f.push(r))}const{scaledOutput:u,scaledConfig:g,scaledKeyNames:d}=n({arrObj:l,weights:o,forceScaling:i}),{scaledOutput:p,scaledConfig:h,scaledKeyNames:y}=n({arrObj:f,weights:o,forceScaling:i}),m=Math.floor(u.length*t);return{trainX:r(u.slice(0,m),c),trainY:r(p.slice(0,m),c),testX:r(u.slice(m),c),testY:r(p.slice(m),c),configX:g,keyNamesX:d,configY:h,keyNamesY:y}},a=({arrObj:e,weights:t={},xCallbackFunc:o,forceScaling:a,timeSteps:s=0})=>{const i=[];for(let t=0;t<e.length;t++){const n=o({objRow:e,index:t});n&&i.push(n)}const{scaledOutput:c,scaledConfig:l,scaledKeyNames:f}=n({arrObj:i,weights:t,forceScaling:a});return{x:r(c,s),configX:l,keyNamesX:f}};XY_Scale=t})();